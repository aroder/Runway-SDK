/*******************************************************************************
 * Copyright (c) 2013 TerraFrame, Inc. All rights reserved.
 * 
 * This file is part of Runway SDK(tm).
 * 
 * Runway SDK(tm) is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 * 
 * Runway SDK(tm) is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with Runway SDK(tm). If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * Created on Aug 11, 2004
 */
package com.runwaysdk.dataaccess;

import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.runwaysdk.business.Business;
import com.runwaysdk.business.BusinessFacade;
import com.runwaysdk.business.generation.GenerationUtil;
import com.runwaysdk.constants.BusinessInfo;
import com.runwaysdk.constants.EntityInfo;
import com.runwaysdk.dataaccess.attributes.entity.Attribute;
import com.runwaysdk.dataaccess.cache.DataNotFoundException;
import com.runwaysdk.dataaccess.cache.ObjectCache;
import com.runwaysdk.dataaccess.database.Database;
import com.runwaysdk.dataaccess.database.RelationshipDAOFactory;
import com.runwaysdk.dataaccess.metadata.MdBusinessDAO;
import com.runwaysdk.dataaccess.metadata.MdElementDAO;
import com.runwaysdk.dataaccess.metadata.MdRelationshipDAO;
import com.runwaysdk.dataaccess.transaction.LockRelationship;
import com.runwaysdk.util.IdParser;

/**
 * A Relationship has a parent and a child BusinessDAO. It also has a collection
 * of attributes. A relationship's type determines the number and type of
 * BusinessDAOs that can be parents and children in the relationship.
 * 
 * @author nathan
 * @version $Revision: 1.88 $
 * @since 1.4s
 */
public class RelationshipDAO extends ElementDAO implements RelationshipDAOIF, Serializable
{
  /**
   * Generated by Eclipse
   */
  private static final long serialVersionUID = 796338853954464656L;

  /**
   * id of the parent BusinessDAO in the relationship. <br/>
   * <b>invariant </b> parenRef != null <br/>
   * <b>invariant </b> !parenRef.trim().equals("") <br/>
   */
  private String            parentId;

  /**
   * id of the child BusinessDAO in the relationship. <br/>
   * <b>invariant </b> childId != null <br/>
   * <b>invariant </b> !childId().equals("") <br/>
   */
  private String            childId;

  /**
   *
   */
  public RelationshipDAO(String parentId, String childId, Map<String, Attribute> attributeMap, String relationshipType)
  {
    super(attributeMap, relationshipType);
    this.parentId = parentId;
    this.childId = childId;
  }

  /**
   * @param childId
   *          Overwrites the parent id if this relationship is new and has not
   *          been applied to the database
   */
  public void overwriteParentId(String parentId)
  {
    if (this.isNew() && !this.isAppliedToDB())
    {
      this.parentId = parentId;
    }
  }

  /**
   * @param childId
   *          Overwrites the child id if this relationship is new and has not
   *          been applied to the database
   */
  public void overwriteChildId(String childId)
  {
    if (this.isNew() && !this.isAppliedToDB())
    {
      this.childId = childId;
    }
  }

  /**
   * Checks the Relationship for several validity constraints: the classes of
   * the parent and child, as well as the cardinality of the parent and child
   * for this relationship.
   */
  protected void validate()
  {
    super.validate();

    // No need to check for cardinality violations if we are simply modifying
    // attributes
    // on this relationship.
    if (!this.isNew() || this.isAppliedToDB())
    {
      return;
    }

    MdRelationshipDAOIF mdRelationshipIF = this.getMdRelationshipDAO();
    MdBusinessDAOIF expectedParentMdBusinessDAOIF = mdRelationshipIF.getParentMdBusiness();
    MdBusinessDAOIF expectedChildMdBusinessDAOIF = mdRelationshipIF.getChildMdBusiness();

    String expectedParentClass = expectedParentMdBusinessDAOIF.definesType();
    String expectedChildClass = expectedChildMdBusinessDAOIF.definesType();

    String parentMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.parentId);
    String childMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.childId);

    MdBusinessDAOIF actualParentMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(parentMdTypeRootId);
    MdBusinessDAOIF actualChildMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(childMdTypeRootId);

    String actualParentClass = actualParentMdBusinessDAOIF.definesType();
    String actualChildClass = actualChildMdBusinessDAOIF.definesType();

    // Ensure that the parent and child exist
    BusinessDAO.get(this.parentId);
    BusinessDAO.get(this.childId);

    // Check if the type of the parent matches what is expected
    if (!expectedParentClass.equals(BusinessInfo.CLASS))
    {
      if (!MdElementDAO.isSubEntity(actualParentClass, expectedParentClass))
      {
        String error = "Relationship [" + mdRelationshipIF.definesType() + "] requires a parent of class [" + expectedParentMdBusinessDAOIF.definesType() + "]. The supplied value is class [" + actualParentClass + "].";
        throw new UnexpectedTypeException(error);
      }
    }

    // Class-check the child against the spec in the Relationship
    if (!expectedChildClass.equals(BusinessInfo.CLASS))
    {
      if (!MdElementDAO.isSubEntity(actualChildClass, expectedChildClass))
      {
        String error = "Relationship [" + mdRelationshipIF.definesType() + "] requires a child of class [" + expectedChildMdBusinessDAOIF.definesType() + "]. The supplied value is class [" + actualChildClass + "].";
        throw new UnexpectedTypeException(error);
      }
    }

    this.validateCardinality(mdRelationshipIF);

    for (MdRelationshipDAOIF mdParentMdRelationshipIF : mdRelationshipIF.getSuperClasses())
    {
      this.validateCardinality((MdRelationshipDAOIF) mdParentMdRelationshipIF);
    }

  }

  /**
   * 
   * @param mdRelationshipIF
   */
  private void validateCardinality(MdRelationshipDAOIF mdRelationshipIF)
  {
    String parentCardinality = mdRelationshipIF.getParentCardinality();
    String childCardinality = mdRelationshipIF.getChildCardinality();

    if (!parentCardinality.equals("*"))
    {
      long existingParentsForChild = Database.getParentCountForChild(childId, mdRelationshipIF.getTableName());

      int cardinality = Integer.parseInt(parentCardinality);

      if (existingParentsForChild >= cardinality)
      {
        String childMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.childId);
        MdBusinessDAOIF childMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(childMdTypeRootId);

        String error = "A [" + childMdBusinessDAOIF.definesType() + "] can only be in " + cardinality + " [" + mdRelationshipIF.definesType() + "] relationships.  The requested operation " + "would put it in " + ( cardinality + 1 ) + ".";

        MdBusinessDAOIF otherMdBusinessIF = mdRelationshipIF.getParentMdBusiness();

        throw new RelationshipCardinalityException(error, childMdBusinessDAOIF, cardinality, mdRelationshipIF, this.childId, otherMdBusinessIF);

      }
    }

    if (!childCardinality.equals("*"))
    {
      long existingChildrenForParent = Database.getChildCountForParent(this.parentId, mdRelationshipIF.getTableName());

      int cardinality = Integer.parseInt(childCardinality);

      if (existingChildrenForParent >= cardinality)
      {
        String parentMdTypeRootId = IdParser.parseMdTypeRootIdFromId(this.parentId);
        MdBusinessDAOIF parentMdBusinessDAOIF = (MdBusinessDAOIF) MdBusinessDAO.getMdClassByRootId(parentMdTypeRootId);

        String error = "A [" + parentMdBusinessDAOIF.definesType() + "] can only be in " + cardinality + " [" + mdRelationshipIF.definesType() + "] relationships.  The requested operation " + "would put it in " + ( cardinality + 1 ) + ".";

        MdBusinessDAOIF otherMdBusinessIF = mdRelationshipIF.getChildMdBusiness();

        throw new RelationshipCardinalityException(error, parentMdBusinessDAOIF, cardinality, mdRelationshipIF, this.parentId, otherMdBusinessIF);
      }
    }

  }

  /**
   * Returns the ID of the Relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> The state of the Relationship does not change <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return The ID of the Relationship
   */
  public String getId()
  {
    return this.getAttributeIF(EntityInfo.ID).getValue();
  }

  /**
   * Returns the id of the parent BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return id of the parent BusinessDAO in this relationship
   */
  public String getParentId()
  {
    return this.parentId;
  }

  /**
   * Returns the parent BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the parent BusinessDAO in this relationship
   */
  public BusinessDAOIF getParent()
  {
    return BusinessDAO.get(this.parentId);
  }

  /**
   * Returns the id of the child BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return id of the child BusinessDAO in this relationship
   */
  public String getChildId()
  {
    return this.childId;
  }

  /**
   * Returns the child BusinessDAO in this relationship.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the child BusinessDAO in this relationship
   */
  public BusinessDAOIF getChild()
  {
    return BusinessDAO.get(this.childId);
  }

  /**
   * Returns the metadata BusinessDAO describing this relationship type.
   * 
   * <br/>
   * <b>Precondition: </b> true <br/>
   * <b>Postcondition: </b> return value != null
   * 
   * @return the metadata BusinessDAO describing this relationship type
   */
  public MdRelationshipDAOIF getMdRelationshipDAO()
  {
    return MdRelationshipDAO.getMdRelationshipDAO(this.getType());
  }

  /**
   * Applies the state of this Relationship to the database. If this is a new
   * Relationship, then records are created in the database and an ID is
   * created. If this is not a new Relationship, then records are modified in
   * the database.
   * 
   * <br/>
   * <b>Precondition: </b> Attribues must have correct values as defined in
   * their meta data. <br/>
   * <b>Postcondition: </b> state of the Relationship is preserved in the
   * database. <br/>
   * <b>Postcondition: </b> return value is not null
   * 
   * @return ID of the Relationship.
   * @throws DataAccessException
   *           if an attribute contains a value that is not correct with respect
   *           to the metadata.
   */
  public String save(boolean save)
  {
    ( LockRelationship.getLockRelationship() ).relLock(this.parentId, this.childId);

    if (this.isNew() && !this.isAppliedToDB())
    {
      // Ensure that the parent and child exist
      BusinessDAO.get(this.parentId);
      BusinessDAO.get(this.childId);
    }

    super.save(save);

    // Aspect will release the lock after the enclosing transaction is complete.

    return this.getId();
  }

  /**
   * Deletes the given relationship from the database.
   * 
   * <br/>
   * <b>Precondition: </b> isNew == false <br/>
   * <b>Postcondition: </b> Relationship is deleted from the database
   * 
   * @param businessContext
   *          true if this is being called from a business context, false
   *          otherwise. If true then cascading deletes of other Entity objects
   *          will happen at the Business layer instead of the data access
   *          layer.
   * 
   */
  public void delete(boolean businessContext)
  {
    super.delete(businessContext);

    MdRelationshipDAOIF mdRelationshipIF = this.getMdRelationshipDAO();
    if (mdRelationshipIF.isComposition())
    {
      BusinessDAOIF childDAOIF = this.getChild();

      if (businessContext && !GenerationUtil.isReservedType(childDAOIF.getMdBusinessDAO()))
      {
        Business business = BusinessFacade.get(childDAOIF);
        business.delete();
      }
      else
      {
        BusinessDAO childObject = childDAOIF.getBusinessDAO();
        childObject.delete();
      }
    }
  }

  /**
   * Return the Relationship instance with the given id. Request is routed to
   * the collection responsible for relationships of the given type.
   * 
   * <br/>
   * <b>Precondition:</b> relId != null <br/>
   * <b>Precondition:</b> !relId.trim().equals("")
   * 
   * @param relId
   *          id of a Relationship
   * @return Relationship object with the given id
   */
  public static RelationshipDAOIF get(String id)
  {
    return ObjectCache.getRelationshipDAO(id);
  }

  /**
   * Return the Relationship instance of the given type with the given key.
   * 
   * <br/>
   * <b>Precondition:</b> type != null <br/>
   * <b>Precondition:</b> !type.trim().equals("") <br/>
   * <b>Precondition:</b> key != null <br/>
   * <b>Precondition:</b> !key.trim().equals("")
   * 
   * @param type
   *          Fully qualified type of a Relationship
   * @param key
   *          The key of a Relationship
   * 
   * @return RelationshipDAO of the given type with the given key
   */
  public static RelationshipDAOIF get(String type, String key)
  {
    return (RelationshipDAOIF) EntityDAO.get(type, key);
  }

  /**
   * Returns a list of relationship objects of the given type with the given
   * parent and child ids. Throws an exception if the relationship does not
   * exist.
   * 
   * <b>Precondition:</b>Assumes that the given relationshipType is concrete.
   * 
   * @param parentId
   * @param childId
   * @param relationshipType
   * @return list of relationship objects of the given type with the given
   *         parent and child ids. Throws an exception if the relationship does
   *         not exist.
   */
  public static List<RelationshipDAOIF> get(BusinessDAOIF parentObjectIF, BusinessDAOIF childObjectIF, String relationshipType)
  {
    return get(parentObjectIF.getId(), childObjectIF.getId(), relationshipType);
  }

  /**
   * Returns a list of relationship objects of the given type with the given
   * parent and child ids. Throws an exception if the relationship does not
   * exist.
   * 
   * <b>Precondition:</b>Assumes that the given relationshipType is concrete.
   * 
   * @param parentId
   * @param childId
   * @param relationshipType
   * @return list of relationship objects of the given type with the given
   *         parent and child ids. Throws an exception if the relationship does
   *         not exist.
   */
  public static List<RelationshipDAOIF> get(String parentId, String childId, String relationshipType)
  {
    List<RelationshipDAOIF> relaitonshipIFList = RelationshipDAOFactory.get(parentId, childId, relationshipType);

    if (relaitonshipIFList.size() == 0)
    {
      MdRelationshipDAOIF mdRelationship = MdRelationshipDAO.getMdRelationshipDAO(relationshipType);
      String errMsg = "A relationship of type [" + relationshipType + "] with parent id [" + parentId + "] and child id [" + childId + "] could not be found.";
      throw new DataNotFoundException(errMsg, mdRelationship);
    }

    return relaitonshipIFList;
  }

  /**
   * 
   * @param relationshipType
   * @return
   */
  public static RelationshipDAO newInstance(String parentId, String childId, String relationshipType)
  {
    return RelationshipDAOFactory.newInstance(parentId, childId, relationshipType);
  }

  /**
   * Returns a clone of the given RelationshipDAO instance. The cloned instance
   * can be applied to the database.
   * 
   * <br/>
   * <b>Precondition:</b> true <br/>
   * <b>Postcondition:</b> Clone (deep copy) of this RelationshipDAO instance is
   * returned.
   * 
   * @return a clone of the given RelationshipDAO instance
   */
  public RelationshipDAO clone()
  {
    HashMap<String, Attribute> newAttrList = new HashMap<String, Attribute>();

    // clone all of the attributes
    for (Attribute attrOld : attributeMap.values())
    {
      Attribute attrNew = attrOld.attributeClone();
      newAttrList.put(attrNew.getName(), attrNew);
    }
    RelationshipDAO clonedObject = RelationshipDAOFactory.factoryMethod(this.getParentId(), this.getChildId(), newAttrList, new String(this.componentType), true);

    clonedObject.setIsNew(this.isNew());
    clonedObject.setAppliedToDB(this.isAppliedToDB());
    return clonedObject;
  }

  /**
   * Returns a copy of the given RelationshipDAO instance, with a new id and
   * mastered at the current site. The state of the object is new and has not
   * been applied to the database.
   * 
   * @return a copy of the given RelationshipDAO instance
   */
  public RelationshipDAO copy()
  {
    HashMap<String, Attribute> newAttrMap = new HashMap<String, Attribute>();

    RelationshipDAO copiedObject = RelationshipDAO.newInstance(this.getParentId(), this.getChildId(), this.getType());

    // clone all of the attributes
    for (Attribute attrOld : attributeMap.values())
    {
      if (! ( attrOld ).getMdAttribute().isSystem())
      {
        Attribute attrNew = attrOld.attributeCopy();
        attrNew.setContainingComponent(copiedObject);
        newAttrMap.put(attrNew.getName(), attrNew);
      }
    }

    // This should overwrite the non-system attributes, such as id and site
    // master
    copiedObject.attributeMap.putAll(newAttrMap);

    return copiedObject;
  }

  @Override
  public boolean equals(Object obj)
  {
    if (obj instanceof RelationshipDAO)
    {
      RelationshipDAO r1 = (RelationshipDAO) obj;

      return this.getId().equals(r1.getId());
    }

    return false;
  }

  public int hashCode()
  {
    return this.getId().hashCode();
  }

  /**
   * Returns a deep cloned-copy of this Relationship
   */
  public RelationshipDAO getRelationshipDAO()
  {
    // Only clone the object if this object comes from a cache.
    if (this.isFromCache())
    {
      return this.clone();
    }
    else
    {
      return this;
    }
  }
}
